---
title: "Random Rotation Package Introduction"
author: "Peter Hettegger"
date: "`r Sys.Date()`"
output:
  BiocStyle::pdf_document:
    toc: TRUE
    fig_width: 4.5
    fig_height: 3.5
vignette: >
  %\VignetteIndexEntry{Random Rotation Package Introduction}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
bibliography: ../inst/library.bib
---


```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  tidy=TRUE
)
```


# Introduction

`randRotation` is an R package intended for generation of randomly rotated data to resample null distributions of linear model based dependent test statistics. See also .............. (Yekutieli Benjamini Paper hier zitieren und später auch das eigene Paper). Possible applications for resampling by roation, that are outlined in this document, are: (i) linear models in combination with practically arbitrary (linear or non-linear) batch effect correction methods --> Section ...; (ii) calculation of resampling based test statistics for calculating resampling based p-values and false discovery rates (FDRs) --> Section ...; (iii) estimation of the degrees of freedoms (df) used by idempotent mapping functions  --> Section ... and (iv) generation of resampled datasets for evaluation of data analysis pipelines --> Section .... Generally, the rotation approach provides a methodology for generating resampled data in the context of linear models and thus potentially has further conceivable areas of applications in high-dimensional data analysis with dependent variables. Nevertheless, we focus this document on the outlined range of issues in order to provide an intuitive and problem-centered introduction.


# Sample dataset {#dataset}

For subsequent analyses we create a hypothetical sample dataset of 3 batches, each containing 5 Control and 5 Cancer samples with 1000 features (genes).

```{r message=FALSE}
library(randRotation)
set.seed(0)
# Dataframe of phenotype data (sample information)
pdata <- data.frame(batch = as.factor(rep(1:3, c(10,10,10))),
                    phenotype = rep(c("Control", "Cancer"), c(5,5)))
features <- 1000

# Matrix with random gene expression data
edata <- matrix(rnorm(features * nrow(pdata)), features)
rownames(edata) <- paste("feature", 1:nrow(edata))

xtabs(data = pdata)
```


# Quick start - linear models with batch effect correction

```{r}
mod1 <- model.matrix(~phenotype, pdata)
head(mod1)
```


```{r}
rr <- init.batch.randrot(Y = edata, X = mod1, coef.h = 2, batch = pdata$batch)
```


```{r}
statistic <- function(Y, batch, mod){
  Y <- sva::ComBat(dat = Y, batch = batch, mod = mod)
  fit1 <- lm.fit(x = mod, y = t(Y))
  t(coef(fit1))[,2]
}
```


```{r message=FALSE, results='hide'}
rs1 <- rotate.stat(initialised.obj = rr, R = 1000, statistic = statistic,
                    batch = pdata$batch, mod = mod1)
```

```{r}
rs1
```


```{r}
p.vals <- p.fdr(rs1)
hist(p.vals)
qqunif(p.vals)
```



# Rotation method - coef.d stay the same under rotation
```{r}
mod0 <- model.matrix(~1, pdata)

statistic <- function(Y, mod){
  coef(lm.fit(x = mod, y = t(Y)))
}

s1 <- statistic(edata, mod0)
s2 <- statistic(randrot(rr), mod0)

all.equal(s1, s2)
```


# Batch effect correction with subsequent linear model analysis 

In the following we outline the use of the `randRotation` package for linear model analysis following batch effect correction as a prototype application in current biomedical research. We highlight the problems faced when batch effect correction is separated from data analysis with linear models. The separation of batch effect correction and subsequent analysis is unavoidable for certain applications. In the following we use `ComBat` (`r Biocpkg("sva")` package) for batch effect correction with subsequent linear model analysis with the `r Biocpkg("limma")` package. For further information about these packages, see [@Ritchie2015;@Leek2019]. We use `limma` and `ComBat` as model functions for demonstration, as these are frequently used in biomedical research. Nevertheless, we want to emphasize that neither the described issues are specific to these functions, nor do we want to somehow defame these highly useful packages.

## Skewed null distribution of p values

Separating (an arbitrary) batch effect correction method from linear model analysis could practically lead to non-uniform (skewed) null distributions of p-values for testing linear model coefficients. The intuitive reason for this skew is that the batch effect correction method combines information of all samples to remove the batch effects. After removing the batch effects, the samples are thus no longer independent. For further information please refer to section [df estimation](#dfest) and to the [references](#references). The following example demonstrates an approach for sample correlation matrices with block design, For other designs please refer to section [Correlation matrices with non-block design](#nonblock).

We first load the `r Biocpkg("limma")` and `r Biocpkg("sva")` packages and create the model matrix with the intercept term and the phenotype term. 

```{r message=FALSE, results='hold'}
library(limma)
library(sva)

mod1 = model.matrix(~phenotype, pdata)

# Linear model fit
fit0 <- lmFit(edata, mod1)
fit0 <- eBayes(fit0)

# P value for phenotype coefficient
p0 <- topTable(fit0, coef = 2, number = Inf, adjust.method = "none", sort.by = "none")$P.Value
hist(p0, freq = FALSE, col = rgb(0,1,0,0.3), breaks = seq(0,1,0.1)); abline(1,0, col = "blue", lty = 2)
qqunif(p0)
```


We now perform batch effect correction using `ComBat`:
```{r}
edata.combat = ComBat(edata, batch = pdata$batch, mod = mod1)
```

The batch effect corrected data is fit with `limma` and subsequently the phenotype covariate is tested for significance. The resulting p-values are shown in the following histogram.

```{r}
# Linear model fit
fit1 <- lmFit(edata.combat, mod1)
fit1 <- eBayes(fit1)

# P value for phenotype coefficient
p.combat <- topTable(fit1, coef = 2, number = Inf, adjust.method = "none", sort.by = "none")$P.Value
hist(p.combat, freq = FALSE, col = rgb(0,1,0,0.3), breaks = seq(0,1,0.1)); abline(1,0, col = "blue", lty = 2)
qqunif(p.combat)
```

Remember that the sample dataset was generated from a random normal distribution. The histogram and Q-Q plot clearly show that the null-distribution of p-values is skewed when linear model analysis is performed following batch effect correction in a data analysis pipeline of this type. This problem is known and described e.g. in [@Nygaard2015]. Note that the null-distribution is skewed although the experimental design is balanced.


## Unskewed p-values with resampling


```{r}
#w = matrix(1+runif(length(edata))-0.5, nrow(edata), ncol(edata))
init1 <- init.batch.randrot(edata, mod1, coef.h = 2, batch = pdata$batch)

statistic <- function(Y, batch, mod, coef){
  Y.tmp <- sva::ComBat(dat = Y, batch = batch, mod = mod)

  fit1 <- limma::lmFit(Y.tmp, mod)
  fit1 <- limma::eBayes(fit1)
  abs(fit1$t[,coef,drop = FALSE])
}

stat.args <- list(batch = pdata$batch, mod = mod1, coef = 2)
```

```{r message=FALSE, results='hide'}

res1 <- rotate.stat(initialised.obj = init1, R = 1000, statistic = statistic, 
                    batch = pdata$batch, mod = mod1, coef = 2,
                    parallel = TRUE)

```

```{r}

p.rot <- p.fdr(res1)
head(p.rot)

hist(p.rot, freq = FALSE, col = rgb(0,1,0,0.3), breaks = seq(0,1,0.1)); abline(1,0, col = "blue", lty = 2)
qqunif(p.rot)

plot(density(log(p.rot/p0)), col = "salmon", "Log p ratios", panel.first = abline(v=0, col = "grey"),
     xlim = range(log(c(p.rot/p0, p.combat/p0))))
lines(density(log(p.combat/p0)), col = "blue")
legend("topleft", legend = c("log( p.combat / p0 )", "log( p.rot / p0 )"), lty = 1, col = c("blue", "salmon"))

plot(p0, p.combat, log = "xy", pch = 19, col = "lightblue", ylab = "")
points(p0, p.rot, pch = 19, col = "salmon")
abline(0,1, lwd = 1.5, col = "black")
legend("topleft", legend = c("p.combat", "p.rot"), pch = 19, col = c("lightblue", "salmon"))

```


Here you see that the combat p-values are downward biased against the "true" null p-values.


```{r}
plot(density(log(p.combat/p.rot)), col = "blue", main = "log( p.combat / p.rot )", panel.first = abline(v=0, col = "grey"))
```
In this plot you see that the combat p-values are biased against the rotation based p values.





# How many resamples ?

In principle the number of resamples (`R`) should be at least as high as the number of features in order to reach unskewed null distributions (for n features --> with a p-value of 1/n you still expect 1 significant feature).


# df estimation {#dfest}

ACHTUNG: Warauf muss man bei df.estimate achten (z.B. wenn man die Combat df's schätzt ) ? Welche coef's muss ich wählen ?


```{r message=FALSE, warning=FALSE, results='hide'}

mapping = function(Y, batch, mod) {
  sva::ComBat(Y, batch, mod)
}

mapping.args = list(batch = pdata$batch, mod = mod1)

idempot(edata, mapping, mapping.args, quantiles = seq(0,1,0.25))
idempot(edata, function(Y)floor(Y))
idempot(edata, function(Y)Y*1.5)

dfs = df.estimate(init1, mapping, mapping.args)
hist(dfs)
summary(dfs)
```


```{r,eval=FALSE,purl=FALSE}

library(limma)
library(sva)

mod1 = model.matrix(~phenotype, pdata)
edata.combat = ComBat(edata, batch = pdata$batch, mod = mod1)
```
```{r, include=FALSE}
library(limma)
library(sva)

mod1 = model.matrix(~phenotype, pdata)
edata.combat = ComBat(edata, batch = pdata$batch, mod = mod1)

```


# Correlation matrices with non-block design {#nonblock}

Function `init.batch.randrot` implicitly assumes a block design of the sample correlation matrix. This means that correlations between samples are allowed within batches, but are zero between batches. Simply put, biological replicates or technical replicates (or any other cause of non-zero sample correlation) are contained within single batches and are not distributed to different batches. In this case, each batch has his own sample correlation matrix and correlation coefficients between batches are assumed to be zero. This assumption seems restrictive at first view, but is computationally efficient and hence implemented in `init.batch.randrot`. However, a general correlation matrix with non-block design (non-zero sample correlations between batches) can be initialised with `init.randrot`. Thus, `init.batch.randrot` simply provides a comfortable wrapper for sample correlation matrices with block design.

# Plots with different FDRs (BH, BY, fdr.q, ...)



# Linear mixed models with batch effect correction

Eventuell design matrix (insbesondere Z matrix) mit lmer erzeugen !

Be very careful with model parametrisation (especially when doing mixed models) ! The best is to test the random rotation by fitting the null models
on the original and rotated data and compare the parameter estimates.


We now assume to have a dataset of repeated measures. We assume to have taken
multiple biopsies of 3 individuals. From each individual we have taken 5
biopsies of healthy control tissue and 5 biopsies of cancer tissue. This is
a possible application for mixed models with the covariate "individual" as
random effect. Although some might cast doubt on examinating covariates with
only 3 levels as random effects, it should be acceptable for demonstration
purposes in this example. We add a small artificial "individual effect".

```{r}
colnames(pdata)[1] <- "individual"
xtabs(data = pdata)

#edata <- t(t(edata) + (as.numeric(pdata$individual) - 2))
```

```{r}
library(lme4)
library(nlme)

df1 <- data.frame(pdata, d1 = edata[1,])
df1 <- df1[-(1:5),]

FUN1 <- function(X, pdata){
  pdata$X <- X
  gls1 <- gls(X ~ 1 + phenotype, pdata, correlation = corCompSymm(form = ~ 1|individual))
  gls0 <- gls(X ~ 1 + phenotype, pdata)
  anova(gls0, gls1)$`p-value`[2]
}

# for(i in 1:10){
#   edata <- matrix(rnorm(features * nrow(pdata)), features)
# rownames(edata) <- paste("feature", 1:nrow(edata))
# 
# ps <- apply(edata, 1, FUN1, pdata = pdata)
# 
# hist(ps)
# }


##### fixed effect als coef.h

me0 <- lmer(d1 ~ 1 + (1|individual), data = df1)
me1 <- lmer(d1 ~ 1 + phenotype + (1|individual), data = df1)

mod1 <- as.matrix(cbind(getME(me1, "X"), getME(me1, "Z")))
head(mod1)
init2 <- init.randrot(Y = t(df1$d1), X = mod1, coef.h = 2)
dim(init2$Xhe.Y.w)

mod3 <- as.matrix(cbind(getME(me1, "X"), getME(me1, "Z")))[,-3]
#mod3 <- model.matrix(~1 + phenotype + individual, df1)
head(mod3)
init3 <- init.randrot(Y = t(df1$d1), X = mod3, coef.h = 2)
dim(init3$Xhe.Y.w)

df2 <- df1
df2$d1 <- randrot(init2)[1,]

df3 <- df1
df3$d1 <- randrot(init3)[1,]

me0
lmer(d1 ~ 1 + (1|individual), data = df2)
lmer(d1 ~ 1 + (1|individual), data = df3)

me1
lmer(d1 ~ 1 + phenotype + (1|individual), data = df2)
lmer(d1 ~ 1 + phenotype + (1|individual), data = df3) ### das müsste das richtige sein


############ Random effect als coef.h

me0 <- gls(d1 ~ 1 + phenotype, data = df1)
me1 <- lmer(d1 ~ 1 + phenotype + (1|individual), data = df1)

mod1 <- as.matrix(cbind(getME(me1, "X"), getME(me1, "Z")))
head(mod1)
init2 <- init.randrot(Y = t(df1$d1), X = mod1, coef.h = 3:5)
dim(init2$Xhe.Y.w)

df2 <- df1
df2$d1 <- randrot(init2)[1,]

me0
gls(d1 ~ 1 + phenotype, data = df1)
gls(d1 ~ 1 + phenotype, data = df2)

me1
gls(d1 ~ 1 + phenotype, data = df1, corCompSymm(form = ~ 1|individual))
gls(d1 ~ 1 + phenotype, data = df2, corCompSymm(form = ~ 1|individual))







dec1 <- X.decomp(mod1, coef.d = c(1,3:5))
dim(dec1$Xd)
dec1$rank
qr(mod1)$rank
qr.Q(qr(mod1))

dec3 <- X.decomp(mod3, coef.d = c(1,3:4))
dim(dec3$Xd)
dec3$rank
qr(mod3)$rank


qr1 <- qr(mod1)
qr(qr.Q(qr1))$rank
zapsmall(qr.Q(qr1))
mod1




gls1 <- gls(d1 ~ 1 + phenotype, df1, correlation = corCompSymm(form = ~ 1|individual))
gls0 <- gls(d1 ~ 1 + phenotype, df1)
gls1

anova(gls0, gls1)

lme1 <- lme(d1 ~ 1 + phenotype, df1, ~ 1|individual, correlation = corCompSymm(form = ~ 1|individual))
lme1
lme1$modelStruct$reStruct
lme2 <- lme(d1 ~ 1 + phenotype, data = df1, random = ~ 1|individual)
lme2
lme2$modelStruct$reStruct




methods(class = class(gls1$modelStruct$corStruct))
corMatrix(gls1$modelStruct$corStruct)

lm1 <- lm(d1 ~ 1 + phenotype, df1)
lm(d1 ~ 1 + phenotype + offset(as.numeric(phenotype)), df1)

df2 <- df1
df2$d1 <- df2$d1 - as.numeric(df1$phenotype)
lm(d1 ~ 1 + phenotype, df2)
lm1
diff(predict(lm1, df1[c(1,11,21)+5,]))

me1 <- lmer(d1 ~ 1 + phenotype + (1|individual), data = df1)

logLik(me1)
logLik(gls1)
logLik(lme1)
logLik(lme2)
me1
gls1
lme1
lme2

diff(ranef(me1)$individual[,1])
lmer(d1 ~ 1 + phenotype + (1|individual), data = df1)

FUN1 <- function(Y, pdata){
  apply(Y, 1, function(d1){
    m1 <- lmer(d1 ~ 1 + phenotype + (1|individual), data = pdata)
    #ranef(m1)$individual[,1]
    getME(m1, "theta")
  })
}

ranefs <- t(FUN1(edata[1:20,], pdata))
dim(ranefs)
hist(ranefs)

```

Test the correct specification of the model by doing a rotation of the null model !!
(Ev. dies auch noch in die help files der funktion schreiben)



<!-- Rang der Z-matrix ?! -->

```{r}
mod1 = cbind(c(1,1,1,1), c(1,1,0,0), c(0,0,1,1))
qr(mod1)

dec1 <-X.decomp(mod1, coef.d = 2:3)

t(dec1$Xd) %*% mod1

Q <-cbind(dec1$Xd, dec1$Xhe)

zapsmall(t(Q) %*% dec1$Xd)

```



<!-- # Parallelisation -->

<!-- ```{r message=FALSE, warning=FALSE, results='hide'} -->
<!-- # register(SnowParam(7)) -->
<!-- # -->
<!-- # times <- list() -->
<!-- # -->
<!-- # t1 = Sys.time() -->
<!-- # res1 <- rotate.stat(init1, 700, statistic, -->
<!-- #                     batch = pdata$batch, mod = mod1, coef = 2) -->
<!-- # times$`700_serial` <- Sys.time()-t1 -->
<!-- # -->
<!-- # t1 = Sys.time() -->
<!-- # res1 <- rotate.stat(init1, 700, statistic, -->
<!-- #                     batch = pdata$batch, mod = mod1, coef = 2, -->
<!-- #                     parallel = TRUE) -->
<!-- # times$`700_parallel` = Sys.time()-t1 -->
<!-- # -->
<!-- # t1 = Sys.time() -->
<!-- # res1 <- rotate.stat(init1, 7000, statistic, -->
<!-- #                     batch = pdata$batch, mod = mod1, coef = 2, -->
<!-- #                     parallel = TRUE) -->
<!-- # times$`7000_parallel` = Sys.time()-t1 -->
<!-- # -->
<!-- # t1 = Sys.time() -->
<!-- # res1 <- rotate.stat(init1, 14000, statistic, -->
<!-- #                     batch = pdata$batch, mod = mod1, coef = 2, -->
<!-- #                     parallel = TRUE) -->
<!-- # times$`14000_parallel` = Sys.time()-t1 -->
<!-- # -->
<!-- # times -->

<!-- ``` -->


# Session info

```{r}
sessionInfo()
```

# References {#references}














